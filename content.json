{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2021-04-06T14:43:28.678Z","updated":"2021-04-06T14:43:28.678Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于我","date":"2021-04-05T08:45:06.906Z","updated":"2021-04-05T08:45:06.906Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"这里是一些关于我的信息"}],"posts":[{"title":"HTTP与HTTPS","slug":"HTTP与HTTPS","date":"2021-12-21T10:09:00.000Z","updated":"2021-12-21T10:10:05.667Z","comments":true,"path":"2021/12/21/HTTP与HTTPS/","link":"","permalink":"http://example.com/2021/12/21/HTTP%E4%B8%8EHTTPS/","excerpt":"","text":"HTTP与HTTPSHTTP与HTTPS简要区别 HTTP HTTPS 明文传输 SSL/TLS加密 无需证书 需要申请证书 响应速度块 响应速度慢 端口80 端口443 HTTP大致流程 发起TCP连接，三次握手 client端发起http请求 server端给出http相应 2，3可能重复若干次 三次tcp挥手，结束连接 HTTPS大致流程 首先客户端通过URL访问服务器建立SSL连接。告知服务器协议版本号，支持的加密方法。 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。 客户端用公钥确认证书有效，用公钥加密一个随机数发给服务器端。 服务器端根据公钥，获取收到的随机数。根据加密协议并生成对话密钥。 SSL协议提供的服务主要有： 1）认证用户和服务器，确保数据发送到正确的客户机和服务器； 2）加密数据以防止数据中途被窃取； 3）维护数据的完整性，确保数据在传输过程中不被改变。 HTTP keep alive和非keep-alive Get Post区别 get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。 get 请求只支持 URL 编码，post 请求支持多种编码格式。 get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。 get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制 get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。 get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个）。","categories":[{"name":"Code","slug":"Code","permalink":"http://example.com/categories/Code/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"author":"sy.piao"},{"title":"GC相关","slug":"GC相关","date":"2021-12-21T10:08:00.000Z","updated":"2021-12-21T10:08:55.581Z","comments":true,"path":"2021/12/21/GC相关/","link":"","permalink":"http://example.com/2021/12/21/GC%E7%9B%B8%E5%85%B3/","excerpt":"","text":"垃圾回收器(GC)Java 常用的垃圾回收器Serial GC最古老的垃圾收集器，“Serial”体现在其收集工作是单线程的，并且在进行垃圾收集过程中，会进入臭名昭著的“Stop-The-World”状态。当然，其单线程设计也意味着精简的 GC 实现，无需维护复杂的数据结构，初始化也简单，所以一直是 Client 模式下 JVM 的默认选项。从年代的角度，通常将其老年代实现单独称作 Serial Old，它采用了标记 - 整理（Mark-Compact）算法，区别于新生代的复制算法。Serial GC 的对应 JVM 参数是： -XX:+UseSerialGC ParNew GC很明显是个新生代 GC 实现，它实际是 Serial GC 的多线程版本，最常见的应用场景是配合老年代的 CMS GC 工作，下面是对应参数 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC CMS（Concurrent Mark Sweep） GC基于标记 - 清除（Mark-Sweep）算法，设计目标是尽量减少停顿时间，这一点对于 Web 等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用 CMS GC。但是，CMS 采用的标记 - 清除算法，存在着内存碎片化问题，所以难以避免在长时间运行等情况下发生 full GC，导致恶劣的停顿。另外，既然强调了并发（Concurrent），CMS 会占用更多 CPU 资源，并和用户线程争抢。 Parallel GC在早期 JDK 8 等版本中，它是 server 模式 JVM 的默认 GC 选择，也被称作是吞吐量优先的 GC。它的算法和 Serial GC 比较相似，尽管实现要复杂的多，其特点是新生代和老年代 GC 都是并行进行的，在常见的服务器环境中更加高效。开启选项是： -XX:+UseParallelGC G1 GC这是一种兼顾吞吐量和停顿时间的 GC 实现，是 Oracle JDK 9 以后的默认 GC 选项。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 region。Region 之间是复制算法，但整体上实际可看作是标记 - 整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。G1 吞吐量和停顿表现都非常不错，并且仍然在不断地完善，与此同时 CMS 已经在 JDK 9 中被标记为废弃（deprecated），所以 G1 GC 值得你深入掌握。 GC原理与基础概念GC主要收集在堆里的对象实例，以及在方法区中的元数据信息，倘若这些信息不再被使用，就应该被GC回收。 GC的对象实例的收集思路 引用技术算法，就是为对象添加一个引用计数，用于记录对象被引用的情况，如果计数为 0，即表示对象可回收。这是很多语言的资源回收选择，例如因人工智能而更加火热的 Python，它更是同时支持引用计数和垃圾收集机制。具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。 可达性分析，Java 的各种引用关系，在某种程度上，将可达性问题还进一步复杂化，具体请参考专栏第 4 讲，这种类型的垃圾收集通常叫作追踪性垃圾收集（Tracing Garbage Collection）。其原理简单来说，就是将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，如果一个对象和 GC Roots 之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。JVM 会把虚拟机栈和本地方法栈中正在引用的对象、静态属性引用的对象和常量，作为 GC Roots。 引用分析算法的缺点： 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; MyObject object1 = new MyObject(); MyObject object2 = new MyObject(); object1.object = object2; object2.object = object1; object1 = null; object2 = null; &#125;&#125; class MyObject&#123; public Object object = null;&#125; 最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数都不为0，那么垃圾收集器就永远不会回收它们。 可达性分析： 即使objD的计数不为1，仍然会被GC回收，因为由GC roots不能达到objD GC roots所包含的对象: 虚拟机栈(栈帧中的本地变量表)中引用的对象。(可以理解为:引用栈帧中的本地变量表的所有对象) 方法区中静态属性引用的对象(可以理解为:引用方法区该静态属性的所有对象) 方法区中常量引用的对象(可以理解为:引用方法区中常量的所有对象) 本地方法栈中(Native方法)引用的对象(可以理解为:引用Native方法的所有对象) 所有被同步锁 (synchronized 关键字) 持有的对象引用 常见的垃圾收集算法： 复制算法，将活着的对象复制到to区域，将对象顺序放置，可以避免内存碎片化。代价是需要提前预留内存空间，有一定的浪费，二是由于是复制，需要维护对象之间的引用关系，需要额外的时间开销。 标记-清除算法（Mark-Sweep）算法，首先进行标记，标记出需要清除的对象，随后清除。代价是会导致内存的碎片化，导致不适合较大的堆。 标记-整理（Mark-Compact）类似标记清除算法，但是会在清理过程中将对象移动，确保对象占用连续的内存空间。 垃圾收集的过程： java不断创建新的对象，这些对象被分配到eden区域。当eden区域的内存占用达到阈值后，触发minor GC。仍然被引用的对象被移动到survivor区域，其余对象被GC回收。 经过一次Minor GC后，eden会空闲下来，直到在此达到minor gc的触发条件。此时，另一个survivor会变成to区域，将from（也就是第一个survivor）和eden区域的对象复制到to区域，存活年限计数会被增加1. 第二步将会发生很多次，直到有对象的年限达到阈值，这时候就会发生promotion，将超过阈值的对象晋升到老年代。这个阈值是可以通过参数指定： -XX:MaxTenuringThreshold= 老年代的GC会根据GC的类型，选择不同的GC算法（e.g. 复制算法, 标记-整理…） GC调优思路GC调优通常关注于以下三个方面： 内存占用(footprint), 延时(latency), 吞吐量(throughtput) 理解应用需求和问题，确定调优目标。假设，我们开发了一个应用服务，但发现偶尔会出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望 GC 暂停尽量控制在 200ms 以内，并且保证一定标准的吞吐量。 掌握 JVM 和 GC 的状态，定位具体的问题，确定真的有 GC 调优的必要。具体有很多方法，比如，通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。例如，通过追踪 GC 日志，就可以查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时。 这里需要思考，选择的 GC 类型是否符合我们的应用特征，如果是，具体问题表现在哪里，是 Minor GC 过长，还是 Mixed GC 等出现异常停顿情况；如果不是，考虑切换到什么类型，如 CMS 和 G1 都是更侧重于低延迟的 GC 选项。 通过分析确定具体调整的参数或者软硬件配置。 验证是否达到调优目标，如果达到目标，即可以考虑结束调优；否则，重复完成分析、调整、验证这个过程。 G1 GC:G1的内存分布为棋盘式设计，jvm会尽可能划分2048个从1m-32m的2的幂级数。这会导致空间的浪费，特别大的对象可能占用超过一个region，过小的对象可能需要连续的region存储。这可以通过设置较大的region大小来进行。 G1的GC算法使用的是复合算法，可以理解为再新生代，使用并行的复制算法，同样会发生Stop-The-World暂停。 在新生代进行的GC叫做minor GC，在老年代进行的GC都叫major GC，Full GC同时作用于新生代和老年代。在垃圾回收过程中经常涉及到对对象的挪动（比如上文提到的对象在Survivor 0和Survivor 1之间的复制），进而导致需要对对象引用进行更新。为了保证引用更新的正确性，Java将暂停所有其他的线程，这种情况被称为“Stop-The-World”，导致系统全局停顿。Stop-The-World对系统性能存在影响，因此垃圾回收的一个原则是尽量减少“Stop-The-World”的时间。 老年代，大部分情况是并发标记，整理过程则是和新生代GC捎带进行，并不是整体性的管理。 g1 gc的简要思路 首先通过printgcdetail 查看fullgc (收集整个堆的引用信息，包括新生代，元空间和老年代)的频率以及时长。 通过dump 查看内存中哪些对象多，这些可能是引起fullgc的原因，看是否能优化。 如果堆大或者是生产环境，可以开起jmc 飞行一段时间，查看这期间的相关数据来订位问题。","categories":[{"name":"Code","slug":"Code","permalink":"http://example.com/categories/Code/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}],"author":"sy.piao"},{"title":"IP协议总结","slug":"IP协议总结","date":"2021-12-20T06:36:00.000Z","updated":"2021-12-20T06:39:58.202Z","comments":true,"path":"2021/12/20/IP协议总结/","link":"","permalink":"http://example.com/2021/12/20/IP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/","excerpt":"","text":"IP协议总结转发与路由选择 转发：指的是分组在单一的路由器的一条输入链路中，由路由器将该分组移动到合适的输出链路。 路由选择： 在一个网络特定范围内，决定分组从源到目的地应采用的端对端路径的决策过程。 时间通常更长 转发表存储于路由器内部，根据分组首部决定向哪个端口进行输出。 IP协议IPv4 version 4bits: 帮助路由器理解如何解释数据报的剩余部分，ipv4 or ipv6 headerlength： 标注首部的长度，因为ip报文提供一些可选项（Options），因此首部的长度可以帮助路由定位数据开始的地方。大多数IP包不包含可选项，因此大多数IP包的首部长度为20（一行为4，5行） Type of Service: 区分这个报文所属的服务类型，e.g. ip电话，ftp等 数据报长度： 单位为byte，表示这个ip包的大小（首部+数据总和） 标识 标志 offset TTL: ip包在网络中存活的时间，每经过一个路由器处理，ttl减一 checksum： 只计算首部，确保首部没有差错。如果路由器计算的checksum与实际不一致，则丢弃这个包。 源和目标IP地址： 包的来源和目标ip，很好理解。 IPv4分片为了将一个较大的ip包拆分为多个小于mtu（最大传送单元，通常为1500byte）的ip包，需要分片。分片的重新组装在端而不是路由器进行。 ipv4 地址32bits，8个bits一个点，binary表示 如192.32.216.9 表示为 11000001 00100000 11011000 00001001 子网，子网掩码223.1.1.0/24 /24代表了这个子网掩码为ip地址二进制表示的前24位。相同子网必定来自于某一个路由器的相同端口 DHCPDHCP是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。无需配置，即插即用，且能确保某一主机每次接入同一网络时获取相同的IP地址。 DHCP的配置分为以下4步： DHCP发现，客户机向67端口进行广播。 DHCP服务器提供：同样进行广播（因为有可能有多个dhcp服务器），告知自身ip，推荐分配的ip，掩码，租用期等信息。 客户机发送dhcp请求，客户机广播自己希望获得的ip。 DHCP ack，验证并同意客户机的请求。 IPv6由于32位ipv4地址即将耗尽，引入了新的ipv6，将源和目标地址的长度延长至128bits 版本： 同ipv4 流量类型： 同ipv4 流标签： 表示数据包的流，可根据需要，对某些流给出优先权或用于区分数据流 载荷长度： 表示在首部之后的字节数量（数据长度）。 跳限制： 类似ipv4的ttl 删除的部分有 分片，重新组装 checksum：由上级协议进行即可，没必要 选项","categories":[{"name":"Code","slug":"Code","permalink":"http://example.com/categories/Code/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"author":"sy.piao"},{"title":"TCP & UDP 总结","slug":"TCP-UDP-总结","date":"2021-12-19T13:25:00.000Z","updated":"2021-12-19T15:08:39.357Z","comments":true,"path":"2021/12/19/TCP-UDP-总结/","link":"","permalink":"http://example.com/2021/12/19/TCP-UDP-%E6%80%BB%E7%BB%93/","excerpt":"","text":"TCP &amp; UDP 总结运输层的多路复用与多路分解将运输层报文段中的数据交付到正确的socket的工作被称作多路分解。 从源主机从不同socket收集数据块，对每个数据块封装上首部信息生成报文段，并将报文段传输至网络层的过程被称作多路复用。 源端口号 目标端口号 其他首部字段 报文内容 UDP为调用UDP的程序提供了一种不可靠，无连接的服务。 适合使用UDP的情况：（典型的：多媒体传输） 对于及时性有较高需求的应用 不需要连接建立的情况（UDP不会引入时延） 无连接状态 （能够支持更多的活跃用户） udp有较小的首部开销 源端口号 目标端口号 长度(包含首部/byte) Checksum 报文 UDP的差错检测UDP checksum计算： 报文部分所有16bits相加，若有进位加到最低位（回卷），最后取反，得到checksum checksum虽然提供差错检测，但是并没有提供恢复能力，仅能丢弃受损的报文段并对应用程序进行警告。 TCP为调用TCP的应用程序提供了一种可靠，面向连接的服务。 TCP的快速重传tcp的超时间隔加倍：第一次tcp超时时间是t，即等待t秒后重传，第二次的重传时间将被设置为2t，第三次重传时间被设置为4t，呈指数型增长。 快速重传解决了超时周期可能过长的问题。发送端发1，2，3，4，5， 接收端收到1，3，4，5，在收到3，4，5时接收端重发三次ACK 2，发送端收到3个冗余的ack2 启动快速重传机制，重发2。这样，发送端就无需等到超时即可重传。 TCP的拥塞控制为了防止发送端使接收端发生缓存溢出的机制（UDP不提供拥塞控制） 发送方会维护一个接收窗口的变量提供流量控制（TCP是全双工，因此两端都有接收窗口），如果发送方发现接收方缓存已满，则停止发送，开启倒计时，倒计时结束后发送试探报文，随后恢复正常。 慢启动慢启动：最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。具体来说，当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长。 拥塞避免从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段。对于大多数TCP实现来说，ssthresh的值是65536(同样以字节计算)。拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。 当出现超时时，结束线性增长。将ssthresh变为cwnd的一半，然后cwnd变为1。 快速恢复发生在三个冗余ack后，每收到一个冗余ack，cwnd增加1；ssthresh和cwnd变为cwnd的一半；当丢失的报文到达后，进入拥塞控制阶段（每次增加1） 下图为有快速恢复和无快速恢复的对比，无快速恢复时，一旦丢包cwnd就从1开始重新增加。 TCP三次握手 发送端发syn 接收端发送syn+ack 发送端发ack TCP四次挥手 发送端发fin 接收端同意fin 接收端发fin 发送端同意fin 为什么建立连接只需要三次握手，结束连接则需要四次回收实际上，建立连接也是四次握手，只不过服务器端发送的ack和syn合成了一个包。这是由于一次tcp链接永远是由客户端s发起的。 ARQ（自动重传请求）（rdt）需要三种协议功能来支撑 差错检测 接收方反馈（TCP的ACK和NAK） 重传能力 （NAK重传，ACK继续） rdt2.2 加入一比特的状态判断位判断新来的包是重传的还是新的包（比特交替协议） rdt3.0 加入倒计时，发送方发完包后等待一定时间若没有收到回应就自动重发 rdt的问题： 停等协议造成的极低发送方利用率 解决方法：允许发送方不等待结果，发送多个报文（流水线），这需要重新设计重传逻辑 流水线的差错恢复 GBN协议（滑动窗口协议） 已被确认 发送但未被确认 可用未被发送 不可用 [0,base-1] [base, nextsequence-1] [nextsequence-1, base+N-1] [base+N, …] 序号字段[0, 2^k-1] (k bits 序号) 特性：按序交付，如果有正确的包不按序到达，全部丢弃。等待未能正确到达的包超时，重新发送，恢复正常。 选择重传 特性：只重传丢失的包，将到达的无序包缓存，等到前序包到达后，进行确认，窗体右移。 限制：窗体大小必须要小于等于序号空间大小的一半 e.g. 序号空间为4，窗体大小为3， 连发0，1，2的ack全部丢失， 0重传 ​ 与 0，1，2成功发送，3发送失败，发送新的0 这两种情况对接收方而言无法区分，为了避免二义性，有上述限制。","categories":[{"name":"Code","slug":"Code","permalink":"http://example.com/categories/Code/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"author":"sy.piao"},{"title":"快排算法的实现","slug":"快排算法的实现","date":"2021-12-18T10:09:00.000Z","updated":"2021-12-18T12:43:44.415Z","comments":true,"path":"2021/12/18/快排算法的实现/","link":"","permalink":"http://example.com/2021/12/18/%E5%BF%AB%E6%8E%92%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"快排算法快排算法本质上是一种分治法，相较于快速排序，快排减少了比较和换位的次数，从而达到了较高的运行速度。其大体思路如下 假设我们对数组arr进行快速排序。 首先在这个序列中随机选一个基准数。 将基准数换到此轮递归的最左侧 先从右向左遍历数组，若找到比基准数小的数停止 再从左向右遍历数组，若找到比基准数大的数停止 交换左右指针所指向的数，重复4，5指导左右指针重合 这样指针的左边全部都是小于基准数的数，指针右边全部都是大于基准数的数 把基准数与指针所指向的数字换位 对此时指针的左边和右边分别进行递归换位 Java代码实现 123456789101112131415161718192021222324252627282930313233public static void qsort(int[] array)&#123; qsortHelper(array, 0, array.length-1);&#125;public static void qsortHelper(int[] array, int left, int right)&#123; // 递归的base case if(left &gt; right) return; // 随机选择一个数字作为基准数； int idx = ((int)Math.random()*(right-left+1))+left; int base = array[idx]; // 把这个数字放到本轮的最左 array[idx] = array[left]; array[left] = base; int l = left; int r = right; while(l&lt;r)&#123; while(array[r]&gt;=base &amp;&amp; l&lt;r)&#123; r--; &#125; while(array[l]&lt;=base &amp;&amp; l&lt;r)&#123; l++; &#125; int tmp = array[l]; array[l] = array[r]; array[r] = tmp; &#125; // 此时l = r // 交换base和此时指针的位置，使得base左边都是比它小的元素， base右边都是比它大的元素 array[left] = array[l]; array[l] = base; // 对两端进行递归快排 qsortHelper(array, left, l-1); qsortHelper(array, l+1, right);&#125;","categories":[{"name":"Code","slug":"Code","permalink":"http://example.com/categories/Code/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"}],"author":"sy.piao"},{"title":"BIO, NIO, AIO(NIO 2) 总结","slug":"BIO, NIO, AIO(NIO 2) 总结","date":"2021-12-18T09:47:00.000Z","updated":"2021-12-18T09:56:00.731Z","comments":true,"path":"2021/12/18/BIO, NIO, AIO(NIO 2) 总结/","link":"","permalink":"http://example.com/2021/12/18/BIO,%20NIO,%20AIO(NIO%202)%20%E6%80%BB%E7%BB%93/","excerpt":"","text":"BIO, NIO, AIO(NIO 2) 总结阻塞/非阻塞描述客户端行为 阻塞： client 提出请求后，等待得到回应才能进行下一个行为 非阻塞： client提出请求后可以进行其他行为 同步/异步描述服务器行为 同步： server 接受一个请求后，返回结果之前不能接受其他请求 异步： server 在接受一个请求后， 尽管没有返回结果，server依然可以接受其他请求。 BIO (Blocking I/O)同步阻塞IO模式，也是最传统的io方式。 123456graph LRc0[Client 0] --&gt;Acceptor[Acceptor]Acceptor --&gt; t0[Thread 0]c1[client 1] --&gt; AcceptorAcceptor --&gt; t1[Thread 1] 通常使用一个独立的Acceptor线程不断监听客户端的链接 123socket.accept();socket.read();socket.write(); 由于涉及的这三个函数都是同步阻塞的，因此BIO模型也是同步阻塞模型，在处理完一个client的请求后才能进行下一步操作。 因此如果希望使BIO通信模型能够处理多个客户端的请求，就必须使用多线程。 伪异步IO为了解决同步阻塞模型的线程处理问题， 当有新的客户端介入时，将客户端的socket封装为task，丢到后端的线程池中进行处理。由于使用了线程池，它的资源是占用是可控的，因此无论有多少个客户端，都不会导致资源的耗尽。 1234567graph LRc0[Client 0] --&gt;Acceptor[Acceptor]Task --&gt; TP(Thread Pool)c1[client 1] --&gt; AcceptorAcceptor --&gt; TaskTP --&gt;|return back| clients NIO (New I/O, Non-blocking I/O)同步非阻塞模型， 提供了Channel, Selector, Buffer等抽象类，这三者也是NIO模型的核心。NIO解决了多线程BIO线程切换代价昂贵的缺点。 Buffer如果说IO是面向流的模型，则NIO是面向缓冲区的模型。 BIO中，所有的数据都是直接在Stream中读写的（BIO有buffer包装类，但是依然是从stream读取到buffer） NIO中， 所有数据都是由Buffer处理，数据直接写入到缓冲区，读取也是从缓冲区中进行读取 Channel为了对Buffer进行读写，我们会使用Channel类，Channel既可以从Buffer 中读取数据，也可以向buffer中写入数据。 12345678graph TBChannel1 --&gt; Buffer1Buffer1 --&gt; Channel1Channel2 --&gt; Buffer2Buffer2 --&gt; Channel2 Selectors选择器用于使用单个线程处理来自多个通道的数据。 1234567graph TBThread --&gt; SelectorSelector --&gt; Channel1Selector --&gt; Channel2Channel1 --&gt; Buffer1Channel2 --&gt; Buffer2 NIO缺陷自行实现的NIO很容易出现各种bug，维护成本高 NIO底层有epoll实现，空轮询会导致cpu的高占用 AIO (异步 I/O)异步非阻塞的模型。 利用事件 与 回调处理Accept 和 Read 等操作。可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。","categories":[{"name":"Code","slug":"Code","permalink":"http://example.com/categories/Code/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"NAS用SSD进行降噪","slug":"NAS用SSD进行降噪","date":"2021-05-29T13:35:00.000Z","updated":"2021-05-29T14:34:03.313Z","comments":true,"path":"2021/05/29/NAS用SSD进行降噪/","link":"","permalink":"http://example.com/2021/05/29/NAS%E7%94%A8SSD%E8%BF%9B%E8%A1%8C%E9%99%8D%E5%99%AA/","excerpt":"","text":"NAS噪音NAS噪音来源主要有两个，散热风扇和机械硬盘。散热风扇这边是我们无法避免的，因为NAS的包含CPU等计算组件，必须进行主动散热才能正常使用，而主动散热无可避免的会使用风扇。因此，我决定从机械硬盘来下手进行降噪。 固态硬盘 (SSD) V.S.机械硬盘（HDD） 固态硬盘 机械硬盘 原理 半导体存储 电磁存储 价格 贵 便宜 工作噪音 无噪音 有噪音 读写速度 极快 较慢 理论寿命 有限的读写次数 无限读写 防震能力 强 弱 数据恢复 难 易 虽然固态硬盘具有有限的读写次数，但实际应用中这个读写上限几乎是不可感知的 固态又分为两种类型：SATA固态和NVME M.2接口的固态。其中，sata接口的固态由于sata通道理论带宽的限制，其最大传输速度是无法超过600mb/s的。而M2接口的固态硬盘没有这一限制。因此有，读写速度：m2 SSD &gt; sata ssd&gt; hdd 由于固态硬盘中没有磁盘，也就不会使磁盘旋转，也就没有了磁盘旋转带来的噪音源，使用固态几乎不会带来任何的磁盘噪音。 降噪思路虽然固态硬盘几乎全是优点，但是如果要在NAS中使用大容量固态，会带来巨额的成本增加。4T的ssd和4T的机械的价格简直是天差地别。为此，改变思路，我希望在不进行读写的时候让HDD休眠。 在NAS运行时，无论是否进行文件读写，系统盘必须保持运作。 为此考虑把系统和应用程序装在ssd中，HDD只用于文件存储。 我所使用的是威联通451D的NAS，只支持2.5寸与3.5寸的SATA接口硬盘。其中，sata接口的SSD基本均为2.5寸。 随便买一个sata接口的ssd，能用就行，要个锤子读写速度，但是注意可用容量必须要大于144GB，即至少买一个标注容量为240GB的SSD，这是因为威联通在建立储存池时的限制。 操作 登陆NAS，备份需要保留的文件，然后关机。重做系统后会格式化所有内容，请务必做好内容备份。 把一槽位的硬盘换成sata ssd，原有的HDD硬盘不要插入nas中。 开机，根据威联通指引，重做系统。然后建立ssd的储存池和卷。 关机，插入HDD，开机。然后建立HDD的储存池和卷。 在NAS中的共享文件夹功能中，分别对ssd和hdd的卷建立共享文件夹。 结果前后噪音对比（dB） 使用机械硬盘作为系统盘 使用SSD作为系统盘 31dB 23dB 讨论 换SSD有用 还想接着降噪的可以想想办法把机器风扇换成猫扇，DIY能力要求比较高，我就不揽这个瓷器活了。","categories":[{"name":"Hardware","slug":"Hardware","permalink":"http://example.com/categories/Hardware/"}],"tags":[{"name":"NAS","slug":"NAS","permalink":"http://example.com/tags/NAS/"}],"author":"sypiao"},{"title":"FF14 AHK编写脚本抢房","slug":"FF14-AHK编写脚本抢房","date":"2021-05-10T12:16:00.000Z","updated":"2021-05-10T12:22:02.451Z","comments":true,"path":"2021/05/10/FF14-AHK编写脚本抢房/","link":"","permalink":"http://example.com/2021/05/10/FF14-AHK%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E6%8A%A2%E6%88%BF/","excerpt":"","text":"FF14 AHK脚本抢房动机尝试过使用python脚本，但是发现python运行的脚本无法在FF14中生效。突然想起以前AHK可以用于DNF连发，遂尝试使用AHK编写脚本进行抢房。 原理FF14的抢房可以用简单的快捷键循环进行实现，即大家耳熟能详的小键盘000040。因此只要使用脚本进行循环输入快捷键循环即可达成自动蹲房的效果。 方法 实现于Windows10，64位系统，mac版本可行性未知 首先需要下载AHK脚本的环境。官方下载地址为：https://www.autohotkey.com/ 其官方文档位于 https://www.autohotkey.com/docs/AutoHotkey.htm 有兴趣的玩家可以自行研究。 完成后在任意位置右键菜单应该可以允许新建AutoHotKey Script文件。 在创建的脚本中右键，选择edit script，用文本编辑器写入代码 粘贴以下代码段，因为我的键盘是87键，没有小键盘，我将小键盘的0和4修改为了L和K。请根据个人情况自行修改。其中，第一行的^;代表使用Shift+;键进行触发。长按F1停用脚本。12345678910111213141516171819^;::loop&#123;if GetKeyState(&quot;F1&quot;, &quot;P&quot;) ; If this statement is true, the user has physically pressed the F1 key. break ; Break out of the loop.Send, lSleep 300Send, lSleep 300Send, lSleep 200Send, lSleep 200Send, kSleep 200Send, lSleep 950&#125;Return ctrl+S保存后，点击运行。发现依然仅能作用于游戏外。 查询资料研究后发现需要作用于FF14中需要以管理员身份运行。 右键脚本，选择compile script会生成一个同名的，exe结尾的可运行文件。 右键.exe文件选择以管理员身份运行，可以正常作用于FF14中。 讨论 猜测以管理员身份运行的话，基于pynput库的python脚本原理上也可以作用于FF14中，未测试。 具体的Sleep时间，即按键延迟可根据个人网络情况进行调整。 请保持人工监视，这只是为了延长键盘寿命的脚本，不要开着脚本去睡觉，这对手动玩家不公平。 未来计划 有空的话开发一个吟游诗人自动弹琴的脚本，感觉会很有意思。","categories":[{"name":"Game","slug":"Game","permalink":"http://example.com/categories/Game/"}],"tags":[{"name":"Script","slug":"Script","permalink":"http://example.com/tags/Script/"}],"author":"pEko"}],"categories":[{"name":"Code","slug":"Code","permalink":"http://example.com/categories/Code/"},{"name":"Hardware","slug":"Hardware","permalink":"http://example.com/categories/Hardware/"},{"name":"Game","slug":"Game","permalink":"http://example.com/categories/Game/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"},{"name":"NAS","slug":"NAS","permalink":"http://example.com/tags/NAS/"},{"name":"Script","slug":"Script","permalink":"http://example.com/tags/Script/"}]}