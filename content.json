{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2021-04-06T14:43:28.678Z","updated":"2021-04-06T14:43:28.678Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于我","date":"2021-04-05T08:45:06.906Z","updated":"2021-04-05T08:45:06.906Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"这里是一些关于我的信息"}],"posts":[{"title":"TCP & UDP 总结","slug":"TCP-UDP-总结","date":"2021-12-19T13:25:00.000Z","updated":"2021-12-19T15:08:39.357Z","comments":true,"path":"2021/12/19/TCP-UDP-总结/","link":"","permalink":"http://example.com/2021/12/19/TCP-UDP-%E6%80%BB%E7%BB%93/","excerpt":"","text":"TCP &amp; UDP 总结运输层的多路复用与多路分解将运输层报文段中的数据交付到正确的socket的工作被称作多路分解。 从源主机从不同socket收集数据块，对每个数据块封装上首部信息生成报文段，并将报文段传输至网络层的过程被称作多路复用。 源端口号 目标端口号 其他首部字段 报文内容 UDP为调用UDP的程序提供了一种不可靠，无连接的服务。 适合使用UDP的情况：（典型的：多媒体传输） 对于及时性有较高需求的应用 不需要连接建立的情况（UDP不会引入时延） 无连接状态 （能够支持更多的活跃用户） udp有较小的首部开销 源端口号 目标端口号 长度(包含首部/byte) Checksum 报文 UDP的差错检测UDP checksum计算： 报文部分所有16bits相加，若有进位加到最低位（回卷），最后取反，得到checksum checksum虽然提供差错检测，但是并没有提供恢复能力，仅能丢弃受损的报文段并对应用程序进行警告。 TCP为调用TCP的应用程序提供了一种可靠，面向连接的服务。 TCP的快速重传tcp的超时间隔加倍：第一次tcp超时时间是t，即等待t秒后重传，第二次的重传时间将被设置为2t，第三次重传时间被设置为4t，呈指数型增长。 快速重传解决了超时周期可能过长的问题。发送端发1，2，3，4，5， 接收端收到1，3，4，5，在收到3，4，5时接收端重发三次ACK 2，发送端收到3个冗余的ack2 启动快速重传机制，重发2。这样，发送端就无需等到超时即可重传。 TCP的拥塞控制为了防止发送端使接收端发生缓存溢出的机制（UDP不提供拥塞控制） 发送方会维护一个接收窗口的变量提供流量控制（TCP是全双工，因此两端都有接收窗口），如果发送方发现接收方缓存已满，则停止发送，开启倒计时，倒计时结束后发送试探报文，随后恢复正常。 慢启动慢启动：最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。具体来说，当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长。 拥塞避免从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段。对于大多数TCP实现来说，ssthresh的值是65536(同样以字节计算)。拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。 当出现超时时，结束线性增长。将ssthresh变为cwnd的一半，然后cwnd变为1。 快速恢复发生在三个冗余ack后，每收到一个冗余ack，cwnd增加1；ssthresh和cwnd变为cwnd的一半；当丢失的报文到达后，进入拥塞控制阶段（每次增加1） 下图为有快速恢复和无快速恢复的对比，无快速恢复时，一旦丢包cwnd就从1开始重新增加。 TCP三次握手 发送端发syn 接收端发送syn+ack 发送端发ack TCP四次挥手 发送端发fin 接收端同意fin 接收端发fin 发送端同意fin 为什么建立连接只需要三次握手，结束连接则需要四次回收实际上，建立连接也是四次握手，只不过服务器端发送的ack和syn合成了一个包。这是由于一次tcp链接永远是由客户端s发起的。 ARQ（自动重传请求）（rdt）需要三种协议功能来支撑 差错检测 接收方反馈（TCP的ACK和NAK） 重传能力 （NAK重传，ACK继续） rdt2.2 加入一比特的状态判断位判断新来的包是重传的还是新的包（比特交替协议） rdt3.0 加入倒计时，发送方发完包后等待一定时间若没有收到回应就自动重发 rdt的问题： 停等协议造成的极低发送方利用率 解决方法：允许发送方不等待结果，发送多个报文（流水线），这需要重新设计重传逻辑 流水线的差错恢复 GBN协议（滑动窗口协议） 已被确认 发送但未被确认 可用未被发送 不可用 [0,base-1] [base, nextsequence-1] [nextsequence-1, base+N-1] [base+N, …] 序号字段[0, 2^k-1] (k bits 序号) 特性：按序交付，如果有正确的包不按序到达，全部丢弃。等待未能正确到达的包超时，重新发送，恢复正常。 选择重传 特性：只重传丢失的包，将到达的无序包缓存，等到前序包到达后，进行确认，窗体右移。 限制：窗体大小必须要小于等于序号空间大小的一半 e.g. 序号空间为4，窗体大小为3， 连发0，1，2的ack全部丢失， 0重传 ​ 与 0，1，2成功发送，3发送失败，发送新的0 这两种情况对接收方而言无法区分，为了避免二义性，有上述限制。","categories":[{"name":"Code","slug":"Code","permalink":"http://example.com/categories/Code/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"author":"sy.piao"},{"title":"快排算法的实现","slug":"快排算法的实现","date":"2021-12-18T10:09:00.000Z","updated":"2021-12-18T12:43:44.415Z","comments":true,"path":"2021/12/18/快排算法的实现/","link":"","permalink":"http://example.com/2021/12/18/%E5%BF%AB%E6%8E%92%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"快排算法快排算法本质上是一种分治法，相较于快速排序，快排减少了比较和换位的次数，从而达到了较高的运行速度。其大体思路如下 假设我们对数组arr进行快速排序。 首先在这个序列中随机选一个基准数。 将基准数换到此轮递归的最左侧 先从右向左遍历数组，若找到比基准数小的数停止 再从左向右遍历数组，若找到比基准数大的数停止 交换左右指针所指向的数，重复4，5指导左右指针重合 这样指针的左边全部都是小于基准数的数，指针右边全部都是大于基准数的数 把基准数与指针所指向的数字换位 对此时指针的左边和右边分别进行递归换位 Java代码实现 123456789101112131415161718192021222324252627282930313233public static void qsort(int[] array)&#123; qsortHelper(array, 0, array.length-1);&#125;public static void qsortHelper(int[] array, int left, int right)&#123; // 递归的base case if(left &gt; right) return; // 随机选择一个数字作为基准数； int idx = ((int)Math.random()*(right-left+1))+left; int base = array[idx]; // 把这个数字放到本轮的最左 array[idx] = array[left]; array[left] = base; int l = left; int r = right; while(l&lt;r)&#123; while(array[r]&gt;=base &amp;&amp; l&lt;r)&#123; r--; &#125; while(array[l]&lt;=base &amp;&amp; l&lt;r)&#123; l++; &#125; int tmp = array[l]; array[l] = array[r]; array[r] = tmp; &#125; // 此时l = r // 交换base和此时指针的位置，使得base左边都是比它小的元素， base右边都是比它大的元素 array[left] = array[l]; array[l] = base; // 对两端进行递归快排 qsortHelper(array, left, l-1); qsortHelper(array, l+1, right);&#125;","categories":[{"name":"Code","slug":"Code","permalink":"http://example.com/categories/Code/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"}],"author":"sy.piao"},{"title":"BIO, NIO, AIO(NIO 2) 总结","slug":"BIO, NIO, AIO(NIO 2) 总结","date":"2021-12-18T09:47:00.000Z","updated":"2021-12-18T09:56:00.731Z","comments":true,"path":"2021/12/18/BIO, NIO, AIO(NIO 2) 总结/","link":"","permalink":"http://example.com/2021/12/18/BIO,%20NIO,%20AIO(NIO%202)%20%E6%80%BB%E7%BB%93/","excerpt":"","text":"BIO, NIO, AIO(NIO 2) 总结阻塞/非阻塞描述客户端行为 阻塞： client 提出请求后，等待得到回应才能进行下一个行为 非阻塞： client提出请求后可以进行其他行为 同步/异步描述服务器行为 同步： server 接受一个请求后，返回结果之前不能接受其他请求 异步： server 在接受一个请求后， 尽管没有返回结果，server依然可以接受其他请求。 BIO (Blocking I/O)同步阻塞IO模式，也是最传统的io方式。 123456graph LRc0[Client 0] --&gt;Acceptor[Acceptor]Acceptor --&gt; t0[Thread 0]c1[client 1] --&gt; AcceptorAcceptor --&gt; t1[Thread 1] 通常使用一个独立的Acceptor线程不断监听客户端的链接 123socket.accept();socket.read();socket.write(); 由于涉及的这三个函数都是同步阻塞的，因此BIO模型也是同步阻塞模型，在处理完一个client的请求后才能进行下一步操作。 因此如果希望使BIO通信模型能够处理多个客户端的请求，就必须使用多线程。 伪异步IO为了解决同步阻塞模型的线程处理问题， 当有新的客户端介入时，将客户端的socket封装为task，丢到后端的线程池中进行处理。由于使用了线程池，它的资源是占用是可控的，因此无论有多少个客户端，都不会导致资源的耗尽。 1234567graph LRc0[Client 0] --&gt;Acceptor[Acceptor]Task --&gt; TP(Thread Pool)c1[client 1] --&gt; AcceptorAcceptor --&gt; TaskTP --&gt;|return back| clients NIO (New I/O, Non-blocking I/O)同步非阻塞模型， 提供了Channel, Selector, Buffer等抽象类，这三者也是NIO模型的核心。NIO解决了多线程BIO线程切换代价昂贵的缺点。 Buffer如果说IO是面向流的模型，则NIO是面向缓冲区的模型。 BIO中，所有的数据都是直接在Stream中读写的（BIO有buffer包装类，但是依然是从stream读取到buffer） NIO中， 所有数据都是由Buffer处理，数据直接写入到缓冲区，读取也是从缓冲区中进行读取 Channel为了对Buffer进行读写，我们会使用Channel类，Channel既可以从Buffer 中读取数据，也可以向buffer中写入数据。 12345678graph TBChannel1 --&gt; Buffer1Buffer1 --&gt; Channel1Channel2 --&gt; Buffer2Buffer2 --&gt; Channel2 Selectors选择器用于使用单个线程处理来自多个通道的数据。 1234567graph TBThread --&gt; SelectorSelector --&gt; Channel1Selector --&gt; Channel2Channel1 --&gt; Buffer1Channel2 --&gt; Buffer2 NIO缺陷自行实现的NIO很容易出现各种bug，维护成本高 NIO底层有epoll实现，空轮询会导致cpu的高占用 AIO (异步 I/O)异步非阻塞的模型。 利用事件 与 回调处理Accept 和 Read 等操作。可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。","categories":[{"name":"Code","slug":"Code","permalink":"http://example.com/categories/Code/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"NAS用SSD进行降噪","slug":"NAS用SSD进行降噪","date":"2021-05-29T13:35:00.000Z","updated":"2021-05-29T14:34:03.313Z","comments":true,"path":"2021/05/29/NAS用SSD进行降噪/","link":"","permalink":"http://example.com/2021/05/29/NAS%E7%94%A8SSD%E8%BF%9B%E8%A1%8C%E9%99%8D%E5%99%AA/","excerpt":"","text":"NAS噪音NAS噪音来源主要有两个，散热风扇和机械硬盘。散热风扇这边是我们无法避免的，因为NAS的包含CPU等计算组件，必须进行主动散热才能正常使用，而主动散热无可避免的会使用风扇。因此，我决定从机械硬盘来下手进行降噪。 固态硬盘 (SSD) V.S.机械硬盘（HDD） 固态硬盘 机械硬盘 原理 半导体存储 电磁存储 价格 贵 便宜 工作噪音 无噪音 有噪音 读写速度 极快 较慢 理论寿命 有限的读写次数 无限读写 防震能力 强 弱 数据恢复 难 易 虽然固态硬盘具有有限的读写次数，但实际应用中这个读写上限几乎是不可感知的 固态又分为两种类型：SATA固态和NVME M.2接口的固态。其中，sata接口的固态由于sata通道理论带宽的限制，其最大传输速度是无法超过600mb/s的。而M2接口的固态硬盘没有这一限制。因此有，读写速度：m2 SSD &gt; sata ssd&gt; hdd 由于固态硬盘中没有磁盘，也就不会使磁盘旋转，也就没有了磁盘旋转带来的噪音源，使用固态几乎不会带来任何的磁盘噪音。 降噪思路虽然固态硬盘几乎全是优点，但是如果要在NAS中使用大容量固态，会带来巨额的成本增加。4T的ssd和4T的机械的价格简直是天差地别。为此，改变思路，我希望在不进行读写的时候让HDD休眠。 在NAS运行时，无论是否进行文件读写，系统盘必须保持运作。 为此考虑把系统和应用程序装在ssd中，HDD只用于文件存储。 我所使用的是威联通451D的NAS，只支持2.5寸与3.5寸的SATA接口硬盘。其中，sata接口的SSD基本均为2.5寸。 随便买一个sata接口的ssd，能用就行，要个锤子读写速度，但是注意可用容量必须要大于144GB，即至少买一个标注容量为240GB的SSD，这是因为威联通在建立储存池时的限制。 操作 登陆NAS，备份需要保留的文件，然后关机。重做系统后会格式化所有内容，请务必做好内容备份。 把一槽位的硬盘换成sata ssd，原有的HDD硬盘不要插入nas中。 开机，根据威联通指引，重做系统。然后建立ssd的储存池和卷。 关机，插入HDD，开机。然后建立HDD的储存池和卷。 在NAS中的共享文件夹功能中，分别对ssd和hdd的卷建立共享文件夹。 结果前后噪音对比（dB） 使用机械硬盘作为系统盘 使用SSD作为系统盘 31dB 23dB 讨论 换SSD有用 还想接着降噪的可以想想办法把机器风扇换成猫扇，DIY能力要求比较高，我就不揽这个瓷器活了。","categories":[{"name":"Hardware","slug":"Hardware","permalink":"http://example.com/categories/Hardware/"}],"tags":[{"name":"NAS","slug":"NAS","permalink":"http://example.com/tags/NAS/"}],"author":"sypiao"},{"title":"FF14 AHK编写脚本抢房","slug":"FF14-AHK编写脚本抢房","date":"2021-05-10T12:16:00.000Z","updated":"2021-05-10T12:22:02.451Z","comments":true,"path":"2021/05/10/FF14-AHK编写脚本抢房/","link":"","permalink":"http://example.com/2021/05/10/FF14-AHK%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E6%8A%A2%E6%88%BF/","excerpt":"","text":"FF14 AHK脚本抢房动机尝试过使用python脚本，但是发现python运行的脚本无法在FF14中生效。突然想起以前AHK可以用于DNF连发，遂尝试使用AHK编写脚本进行抢房。 原理FF14的抢房可以用简单的快捷键循环进行实现，即大家耳熟能详的小键盘000040。因此只要使用脚本进行循环输入快捷键循环即可达成自动蹲房的效果。 方法 实现于Windows10，64位系统，mac版本可行性未知 首先需要下载AHK脚本的环境。官方下载地址为：https://www.autohotkey.com/ 其官方文档位于 https://www.autohotkey.com/docs/AutoHotkey.htm 有兴趣的玩家可以自行研究。 完成后在任意位置右键菜单应该可以允许新建AutoHotKey Script文件。 在创建的脚本中右键，选择edit script，用文本编辑器写入代码 粘贴以下代码段，因为我的键盘是87键，没有小键盘，我将小键盘的0和4修改为了L和K。请根据个人情况自行修改。其中，第一行的^;代表使用Shift+;键进行触发。长按F1停用脚本。12345678910111213141516171819^;::loop&#123;if GetKeyState(&quot;F1&quot;, &quot;P&quot;) ; If this statement is true, the user has physically pressed the F1 key. break ; Break out of the loop.Send, lSleep 300Send, lSleep 300Send, lSleep 200Send, lSleep 200Send, kSleep 200Send, lSleep 950&#125;Return ctrl+S保存后，点击运行。发现依然仅能作用于游戏外。 查询资料研究后发现需要作用于FF14中需要以管理员身份运行。 右键脚本，选择compile script会生成一个同名的，exe结尾的可运行文件。 右键.exe文件选择以管理员身份运行，可以正常作用于FF14中。 讨论 猜测以管理员身份运行的话，基于pynput库的python脚本原理上也可以作用于FF14中，未测试。 具体的Sleep时间，即按键延迟可根据个人网络情况进行调整。 请保持人工监视，这只是为了延长键盘寿命的脚本，不要开着脚本去睡觉，这对手动玩家不公平。 未来计划 有空的话开发一个吟游诗人自动弹琴的脚本，感觉会很有意思。","categories":[{"name":"Game","slug":"Game","permalink":"http://example.com/categories/Game/"}],"tags":[{"name":"Script","slug":"Script","permalink":"http://example.com/tags/Script/"}],"author":"pEko"}],"categories":[{"name":"Code","slug":"Code","permalink":"http://example.com/categories/Code/"},{"name":"Hardware","slug":"Hardware","permalink":"http://example.com/categories/Hardware/"},{"name":"Game","slug":"Game","permalink":"http://example.com/categories/Game/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"},{"name":"NAS","slug":"NAS","permalink":"http://example.com/tags/NAS/"},{"name":"Script","slug":"Script","permalink":"http://example.com/tags/Script/"}]}